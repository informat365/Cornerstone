{"version":3,"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/./sources/core/relations/links_builder.js","webpack://[name]/./sources/utils/helpers.js","webpack://[name]/./sources/ext/auto_scheduling/constraint_types.ts","webpack://[name]/./sources/core/relations/graph_helper.js","webpack://[name]/./sources/core/relations/links_common.js","webpack://[name]/./sources/ext/auto_scheduling/ui_handlers.ts","webpack://[name]/./sources/ext/auto_scheduling/loops_finder.ts","webpack://[name]/./sources/ext/auto_scheduling/connected_groups.ts","webpack://[name]/./sources/ext/auto_scheduling/asap_strategy.ts","webpack://[name]/./sources/ext/auto_scheduling/alap_strategy.ts","webpack://[name]/./sources/ext/auto_scheduling/planner.ts","webpack://[name]/./sources/ext/auto_scheduling/constraints.ts","webpack://[name]/./sources/ext/auto_scheduling.js","webpack://[name]/./sources/ext/auto_scheduling/task_plan.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","gantt","getVirtualRoot","mixin","getSubtaskDates","id","config","root_id","type","types","project","$source","$target","$virtual","getLinkedTasks","includePredecessors","startIds","clearCache","_isLinksCacheEnabled","_startLinksCache","relations","visited","result","length","this","_getLinkedTasks","push","_endLinksCache","_collectRelations","rootObj","isChild","visitedLinks","linkKey","successors","_getSuccessors","predecessors","_getPredecessors","hashSum","rootTask","visitedTasks","output","from","undefined","tasksStack","current","pop","isTaskExists","getTask","rel","isSameParent","sourceParent","targetParent","target","hasChild","children","getChildren","units","second","minute","hour","day","week","month","quarter","year","isDate","obj","getFullYear","getMonth","getDate","arrayFilter","arr","callback","filter","getSecondsInUnit","unit","forEach","workArray","slice","arrayMap","map","resArray","arrayFind","find","arrayDifference","item","arraySome","hashToArray","hash","sortArrayOfHash","field","desc","compare","a","b","sort","throttle","timeout","wait","apply","arguments","setTimeout","isArray","Array","isValidDate","isNaN","getTime","isStringObject","Function","toString","constructor","isNumberObject","isBooleanObject","delay","timer","$cancelTimeout","$pending","args","clearTimeout","$execute","objectKeys","keys","requestAnimationFrame","w","webkitRequestAnimationFrame","msRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","cb","isEventable","attachEvent","detachEvent","ConstraintTypes","helpers","getVertices","ids","len","source","vertices","topologicalSort","edges","$incoming","successor","S","v","L","node","groupAdjacentEdges","edge","res","tarjanStronglyConnectedComponents","verticesHash","stack","edgesFromTasks","recurse","connectedComponents","getVertex","workStack","index","lowLink","onStack","e","Math","min","com","tasks","links","findLoops","cycles","component","_get_linked_task","link","getTarget","task","taskId","_get_link_target","_get_link_source","caching","formattedLinksStash","inheritedSuccessorsStash","inheritedPredecessorsStash","getPredecessorsCache","_formatLink","isSummaryTask","isChildOf","_getImplicitLinks","respectTargetOffset","auto_scheduling_move_projects","targetDates","start_date","end_date","to","getState","drag_id","calculateDuration","fromLength","fromTask","j","toLength","toTask","lag","subtaskLink","_convertToFinishToStartLink","taskParent","_isAutoSchedulable","auto_scheduling","parent","selectOffset","selectSourceLinks","skipChild","eachTask","linksCollection","siblingLink","getLink","siblingId","siblingTask","abs","duration","_getDirectDependencies","selectSuccessors","linksIds","concat","_getInheritedDependencies","cacheCollection","stop","inheritedRelations","eachParent","parentDependencies","_getDirectSuccessors","_getInheritedSuccessors","_getDirectPredecessors","_getInheritedPredecessors","skipInherited","String","sourceTask","targetTask","finish_to_start","preferredStart","additionalLag","start_to_start","finish_to_finish","start_to_finish","attachUIHandlers","linksBuilder","loopsFinder","connectedGroupsHelper","_attachAutoSchedulingHandlers","movedTask","_scheduleAfterBatchUpdate","_autoScheduleAfterLinkChange","_autoscheduling_in_progress","batch_update","autoSchedule","_preventCircularLink","isCircularLink","callEvent","getLoopContainingLink","_preventDescendantLink","auto_scheduling_descendant_links","_datesNotEqual","dateA","dateB","taskA","taskB","valueOf","_hasDuration","_notEqualTaskDates","task1","task2","getConstraintType","constraint_date","milestone","getRelations","auto_scheduling_compatibility","getConnectedGroupRelations","updateTaskConstraints","schedule_from_end","constraint_type","constraint_types","FNLT","Date","SNET","finalizeTaskConstraints","auto_scheduling_strict","auto_scheduling_initial","changedConstraint","_autoScheduleAfterDND","newTask","relationsArray","skipped","originalLink","splice","presentLinks","updatedLinks","resetToStartLinksLags","_autoSchedule","modifiedTaskId","ext","inlineEditors","autoscheduleColumns_1","state","columnName","editorConfig","getEditorConfig","map_to","oldTask","LoopsFinder","graphHelper","_this","_graphHelper","_linksBuilder","_gantt","allRelations","isLinkExists","findCycles","breadthFirstSearch","currentVertex","queue","groupTasks","groupLinksInternal","groupLinksPublic","shift","linksArray","linksObjects","processedLinks","ConnectedGroupsHelper","getConnectedGroup","group","groups","length_1","findGroups","task_plan_1","AsapStrategy","Create","instance","resolveRelationDate","adjacentLinks","plansHash","minStart","linkId","defaultStart","minRelationDate","relation","constraintDate","getEarliestStartDate","isSmallerOrDefault","project_start","maxEnd","getClosestWorkTime","date","dir","calculateEndDate","masterPlan","currentPlan","TaskPlan","kind","earliestSchedulingStart","earliestSchedulingEnd","isEqual","isFirstSmaller","small","big","smallDate","bigDate","getPredecessorEndDate","plan","predecessorEnd","successorStart","AlapStrategy","maxStart","maxRelationDate","getLatestEndDate","constraintStartDate","isGreaterOrDefault","project_end","latestSchedulingStart","latestSchedulingEnd","getSuccessorStartDate","predecessor","alap_strategy_1","asap_strategy_1","constraint_types_1","AutoSchedulingPlanner","constraintsHelper","_constraintsHelper","_asapStrategy","_alapStrategy","generatePlan","constraints","alapStrategy","asapStrategy","_a","buildWorkCollections","orderedIds","reversedIds","relationsMap","processConstraints","iterateTasks","isAlapTask","isAsapTask","applyProjectPlan","projectPlan","reason","updateTasks","newDate","mainSequence","secondarySequence","isMainSequence","mainSequenceStrategy","secondarySequenceStrategy","currentId","limitPlanDates","processResolvedDate","effectiveStart","earliestStart","earliestEnd","latestStart","latestEnd","conflict","reverse","unshift","constraintType","ASAP","ALAP","processConstraint","ConstraintsHelper","hasConstraint","newPlan","SNLT","FNET","MSO","MFO","getConstraints","store","planner","connectedGroups","getConstraintLimitations","updatedTasks","startTask","preferInitialTaskDates","batchUpdate","payload","updateTask","resetTime","start","end","resetProjectDates","updateParentsAndCallEvents","inclusive","auto_scheduling_compatible","parseDate"],"mappings":"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","file":"ext/dhtmlxgantt_auto_scheduling.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ext/dhtmlxgantt_auto_scheduling\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ext/dhtmlxgantt_auto_scheduling\"] = factory();\n\telse\n\t\troot[\"ext/dhtmlxgantt_auto_scheduling\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/codebase/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 269);\n","module.exports = function(gantt) {\n\treturn {\n\t\tgetVirtualRoot: function(){\n\t\t\treturn gantt.mixin(\n\t\t\t\tgantt.getSubtaskDates(),\n\t\t\t\t{\n\t\t\t\t\tid: gantt.config.root_id,\n\t\t\t\t\ttype: gantt.config.types.project,\n\t\t\t\t\t$source: [],\n\t\t\t\t\t$target: [],\n\t\t\t\t\t$virtual: true\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\n\t\tgetLinkedTasks: function(id, includePredecessors){\n\t\t\tvar startIds = [id];\n\t\n\t\t\t//TODO: format links cache\n\t\t\tvar clearCache = false;\n\t\t\tif(!gantt._isLinksCacheEnabled()) {\n\t\t\t\tgantt._startLinksCache();\n\t\t\t\tclearCache = true;\n\t\t\t}\n\t\t\tvar relations = [];\n\t\t\tvar visited = {};\n\t\t\tvar result = {};\n\t\t\tfor(var i = 0; i < startIds.length; i++){\n\t\t\t\tthis._getLinkedTasks(startIds[i], visited, includePredecessors, result);\n\t\t\t}\n\t\n\t\t\tfor(var i in result){\n\t\t\t\trelations.push(result[i]);\n\t\t\t}\n\t\n\t\t\t//TODO: remove redundant edges before continue https://en.wikipedia.org/wiki/Transitive_reduction\n\t\t\tif(clearCache)\n\t\t\t\tgantt._endLinksCache();\n\t\t\treturn relations;\n\t\t},\n\t\n\t\t_collectRelations: function(rootObj, isChild, includePredecessors, visitedLinks){\n\t\t\tvar successors = gantt._getSuccessors(rootObj, isChild);\n\t\n\t\t\tvar predecessors = [];\n\t\t\tif (includePredecessors) {\n\t\t\t\tpredecessors = gantt._getPredecessors(rootObj, isChild);\n\t\t\t}\n\t\t\t\n\t\t\tvar linkKey;\n\t\t\tvar relations = [];\n\t\t\tfor(var i = 0; i < successors.length; i++){\n\t\t\t\tlinkKey = successors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(successors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(var i = 0; i < predecessors.length; i++){\n\t\t\t\tlinkKey = predecessors[i].hashSum;\n\t\t\t\tif(visitedLinks[linkKey]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tvisitedLinks[linkKey] = true;\n\t\t\t\t\trelations.push(predecessors[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn relations;\n\t\t},\n\t\t_getLinkedTasks: function(rootTask, visitedTasks, includePredecessors, output) {\n\t\t\tvar from = rootTask === undefined ? gantt.config.root_id : rootTask;\n\t\t\tvar visitedTasks = {};\n\t\t\tvar visitedLinks = {};\n\t\t\tvar rootObj;\n\t\n\t\t\tvar tasksStack = [{from: from, includePredecessors: includePredecessors, isChild:false}];\n\t\n\t\t\twhile(tasksStack.length){\n\t\t\t\tvar current = tasksStack.pop();\n\t\t\t\tvar isChild = current.isChild;\n\t\n\t\t\t\tfrom = current.from;\n\t\t\t\tif(visitedTasks[from]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trootObj = gantt.isTaskExists(from) ? gantt.getTask(from) : this.getVirtualRoot();\n\t\t\t\tvisitedTasks[from] = true;\n\t\t\t\t\n\t\t\t\tvar relations = this._collectRelations(rootObj, isChild, includePredecessors, visitedLinks);\n\t\n\t\t\t\tfor(var i=0; i < relations.length; i++){\n\t\t\t\t\tvar rel = relations[i];\n\t\t\t\t\toutput[rel.hashSum] = rel;\n\t\t\t\t\tvar isSameParent = rel.sourceParent == rel.targetParent;\n\t\t\t\t\tvar targetTask = rel.target;\n\t\t\t\t\tif(!visitedTasks[targetTask])\n\t\t\t\t\t\ttasksStack.push({from: rel.target, includePredecessors: true, isChild: isSameParent});\n\t\t\t\t}\n\t\n\t\t\t\tif(gantt.hasChild(rootObj.id)){\n\t\t\t\t\tvar children = gantt.getChildren(rootObj.id);\n\t\t\t\t\tfor(var i=0; i < children.length; i++){\n\t\t\t\t\t\tif(!visitedTasks[children[i]])\n\t\t\t\t\t\t\ttasksStack.push({from: children[i], includePredecessors: true, isChild: true});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn output;\n\t\t}\n\t};\n};","var units = {\n\t\"second\": 1,\n\t\"minute\": 60,\n\t\"hour\": 60 * 60,\n\t\"day\": 60 * 60 * 24,\n\t\"week\": 60 * 60 * 24 * 7,\n\t\"month\": 60 * 60 * 24 * 30,\n\t\"quarter\": 60 * 60 * 24 * 30 * 3,\n\t\"year\": 60 * 60 * 24 * 365\n};\nfunction getSecondsInUnit(unit){\n\treturn units[unit] || units.hour;\n}\n\nfunction forEach(arr, callback) {\n\tif (arr.forEach) {\n\t\tarr.forEach(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tcallback(workArray[i], i);\n\t\t}\n\t}\n}\n\nfunction arrayMap(arr, callback) {\n\tif (arr.map) {\n\t\treturn arr.map(callback);\n\t} else {\n\t\tvar workArray = arr.slice();\n\t\tvar resArray = [];\n\n\t\tfor (var i = 0; i < workArray.length; i++) {\n\t\t\tresArray.push(callback(workArray[i], i));\n\t\t}\n\t\treturn resArray;\n\t}\n}\n\n\nfunction arrayFind(arr, callback) {\n\tif (arr.find) {\n\t\treturn arr.find(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\treturn arr[i];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// iframe-safe array type check instead of using instanceof\nfunction isArray(obj){\n\tif(Array.isArray){\n\t\treturn Array.isArray(obj);\n\t}else{\n\t\t// close enough\n\t\treturn (obj && obj.length !== undefined && obj.pop && obj.push);\n\t}\n}\n\n// non-primitive string object, e.g. new String(\"abc\")\nfunction isStringObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function String() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Number(5)\nfunction isNumberObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Number() { [native code] }\";\n}\n\n// non-primitive number object, e.g. new Boolean(true)\nfunction isBooleanObject(obj){\n\treturn obj && typeof obj === \"object\"\n\t\t&& Function.prototype.toString.call(obj.constructor) === \"function Boolean() { [native code] }\";\n}\n\nfunction isDate(obj) {\n\tif (obj && typeof obj === \"object\") {\n\t\treturn !!(obj.getFullYear && obj.getMonth && obj.getDate);\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction isValidDate(obj){\n\treturn isDate(obj) && !isNaN(obj.getTime());\n}\n\nfunction arrayFilter(arr, callback) {\n\tvar result = [];\n\n\tif (arr.filter) {\n\t\treturn arr.filter(callback);\n\t} else {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (callback(arr[i], i)) {\n\t\t\t\tresult[result.length] = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nfunction hashToArray(hash) {\n\tvar result = [];\n\n\tfor (var key in hash) {\n\t\tif (hash.hasOwnProperty(key)) {\n\t\t\tresult.push(hash[key]);\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction arraySome(arr, callback) {\n\tif (arr.length === 0) return false;\n\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tif (callback(arr[i], i, arr)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nfunction arrayDifference(arr, callback) {\n\treturn arrayFilter(arr, function(item, i) {\n\t\treturn !callback(item, i);\n\t});\n}\n\nfunction throttle (callback, timeout) {\n\tvar wait = false;\n\n\treturn function () {\n\t\tif (!wait) {\n\t\t\tcallback.apply(null, arguments);\n\t\t\twait = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\twait = false;\n\t\t\t}, timeout);\n\t\t}\n\t};\n}\n\nfunction delay (callback, timeout){\n\tvar timer;\n\n\tvar result = function() {\n\t\tresult.$cancelTimeout();\n\t\tcallback.$pending = true;\n\t\tvar args = Array.prototype.slice.call(arguments);\n\t\ttimer = setTimeout(function(){\n\t\t\tcallback.apply(this, args);\n\t\t\tresult.$pending = false;\n\t\t}, timeout);\n\t};\n\t\n\tresult.$pending = false;\n\tresult.$cancelTimeout = function(){\n\t\tclearTimeout(timer);\n\t\tcallback.$pending = false;\n\t};\n\tresult.$execute = function(){\n\t\tcallback();\n\t\tcallback.$cancelTimeout();\n\t};\n\n\treturn result;\n}\n\nfunction sortArrayOfHash(arr, field, desc) {\n\tvar compare = function(a, b) {\n\t\treturn a < b;\n\t};\n\n\tarr.sort(function(a, b) {\n\t\tif (a[field] === b[field]) return 0;\n\n\t\treturn desc ? compare(a[field], b[field]) : compare(b[field], a[field]);\n\t});\n}\n\nfunction objectKeys(obj) {\n\tif (Object.keys) {\n\t\treturn Object.keys(obj);\n\t}\n\tvar result = [];\n\tvar key;\n\tfor (key in obj) {\n\t\tif (Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\tresult.push(key);\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction requestAnimationFrame(callback) {\n\tvar w = window;\n\tvar foundRequestAnimationFrame = w.requestAnimationFrame\n\t\t|| w.webkitRequestAnimationFrame\n\t\t|| w.msRequestAnimationFrame\n\t\t|| w.mozRequestAnimationFrame\n\t\t|| w.oRequestAnimationFrame\n\t\t|| function(cb) { setTimeout(cb, 1000/60); };\n\treturn foundRequestAnimationFrame(callback);\n}\n\nfunction isEventable(obj) {\n\treturn obj.attachEvent && obj.detachEvent;\n}\n\nmodule.exports = {\n\tgetSecondsInUnit: getSecondsInUnit,\n\tforEach: forEach,\n\tarrayMap: arrayMap,\n\tarrayFind: arrayFind,\n\tarrayFilter: arrayFilter,\n\tarrayDifference: arrayDifference,\n\tarraySome: arraySome,\n\thashToArray: hashToArray,\n\tsortArrayOfHash: sortArrayOfHash,\n\tthrottle: throttle,\n\tisArray: isArray,\n\tisDate: isDate,\n\tisValidDate: isValidDate,\n\tisStringObject: isStringObject,\n\tisNumberObject: isNumberObject,\n\tisBooleanObject: isBooleanObject,\n\tdelay: delay,\n\tobjectKeys: objectKeys,\n\trequestAnimationFrame: requestAnimationFrame,\n\tisEventable: isEventable\n};","export enum ConstraintTypes {\n\t// As Soon As Possible (ASAP)\n\tASAP = \"asap\",\n\t// As Late As Possible (ALAP)\n\tALAP = \"alap\",\n\t// Start No Earlier Than (SNET)\n\tSNET = \"snet\",\n\t// Start No Later Than (SNLT)\n\tSNLT = \"snlt\",\n\t// Finish No Earlier Than (FNET)\n\tFNET = \"fnet\",\n\t// Finish No Later Than (FNLT)\n\tFNLT = \"fnlt\",\n\t// Must Start On (MSO)\n\tMSO = \"mso\",\n\t// Must Finish On (MFO)\n\tMFO = \"mfo\"\n}","var helpers = require(\"../../utils/helpers\");\n\nmodule.exports = function(){\n\treturn {\n\t\tgetVertices: function(relations){\n\t\t\tvar ids = {};\n\t\t\tvar rel;\n\t\t\tfor(var i = 0, len = relations.length; i < len; i++){\n\t\t\t\trel = relations[i];\n\t\t\t\tids[rel.target] = rel.target;\n\t\t\t\tids[rel.source] = rel.source;\n\t\t\t}\n\n\t\t\tvar vertices = [];\n\t\t\tvar id;\n\t\t\tfor(var i in ids){\n\t\t\t\tid = ids[i];\n\t\t\t\tvertices.push(id);\n\t\t\t}\n\n\t\t\treturn vertices;\n\t\t},\n\t\ttopologicalSort: function(edges){\n\t\t\tvar vertices = this.getVertices(edges);\n\t\t\tvar hash = {};\n\n\t\t\tfor(var i = 0, len = vertices.length; i < len; i ++){\n\t\t\t\thash[vertices[i]] = {id: vertices[i], $source:[], $target:[], $incoming: 0};\n\t\t\t}\n\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tvar successor = hash[edges[i].target];\n\t\t\t\tsuccessor.$target.push(i);\n\t\t\t\tsuccessor.$incoming = successor.$target.length;\n\t\t\t\thash[edges[i].source].$source.push(i);\n\n\t\t\t}\n\n\t\t\t// topological sort, Kahn's algorithm\n\t\t\tvar S = vertices.filter(function(v){ return !hash[v].$incoming; });\n\n\t\t\tvar L = [];\n\n\t\t\twhile(S.length){\n\t\t\t\tvar n = S.pop();\n\n\t\t\t\tL.push(n);\n\n\t\t\t\tvar node = hash[n];\n\n\t\t\t\tfor(var i = 0; i < node.$source.length; i++){\n\t\t\t\t\tvar m = hash[edges[node.$source[i]].target];\n\t\t\t\t\tm.$incoming--;\n\t\t\t\t\tif(!m.$incoming){\n\t\t\t\t\t\tS.push(m.id);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn L;\n\n\t\t},\n\t\tgroupAdjacentEdges: function(edges){\n\t\t\tvar res = {};\n\t\t\tvar edge;\n\t\t\tfor(var i = 0, len = edges.length; i < len; i++){\n\t\t\t\tedge = edges[i];\n\t\t\t\tif(!res[edge.source]){\n\t\t\t\t\tres[edge.source] = [];\n\t\t\t\t}\n\t\t\t\tres[edge.source].push(edge);\n\t\t\t}\n\t\t\treturn res;\n\t\t},\n\t\ttarjanStronglyConnectedComponents: function(vertices, edges){\n\t\t\t//https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n\t\t\t// iterative implementation\n\t\t\tvar verticesHash = {};\n\t\t\tvar stack = [];\n\t\t\tvar edgesFromTasks = this.groupAdjacentEdges(edges);\n\t\t\tvar recurse = false;\n\t\t\tvar connectedComponents = [];\n\n\t\t\tfor(var i = 0; i < vertices.length; i++){\n\t\t\t\tvar root = getVertex(vertices[i]);\n\t\t\t\tif(root.visited) continue;\n\t\t\t\tvar workStack = [root];\n\t\t\t\tvar index = 0;\n\t\t\t\twhile(workStack.length){\n\t\t\t\t\tvar v = workStack.pop();\n\n\t\t\t\t\tif(!v.visited){\n\t\t\t\t\t\tv.index = index;\n\t\t\t\t\t\tv.lowLink = index;\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tstack.push(v);\n\t\t\t\t\t\tv.onStack = true;\n\t\t\t\t\t\tv.visited = true;\n\t\t\t\t\t}\n\t\t\t\t\trecurse = false;\n\t\t\t\t\tvar edges = edgesFromTasks[v.id] || [];\n\t\t\t\t\tfor(var e = 0; e < edges.length; e++){\n\t\t\t\t\t\tvar w = getVertex(edges[e].target);\n\t\t\t\t\t\tw.edge = edges[e];\n\t\t\t\t\t\tif(w.index === undefined){\n\t\t\t\t\t\t\tworkStack.push(v);\n\t\t\t\t\t\t\tworkStack.push(w);\n\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(w.onStack){\n\t\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(recurse)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (v.index == v.lowLink){\n\t\t\t\t\t\tvar com = {tasks:[], links:[]};\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tw = stack.pop();\n\t\t\t\t\t\t\tw.onStack = false;\n\t\t\t\t\t\t\tcom.tasks.push(w.id);\n\t\t\t\t\t\t\tif(w.edge){\n\t\t\t\t\t\t\t\tcom.links.push(w.edge.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(w == v){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconnectedComponents.push(com);\n\t\t\t\t\t}\n\t\t\t\t\tif(workStack.length){\n\t\t\t\t\t\tw = v;\n\t\t\t\t\t\tv = workStack[workStack.length - 1];\n\t\t\t\t\t\tv.lowLink = Math.min(v.lowLink, w.lowLink);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn connectedComponents;\n\n\t\t\tfunction getVertex(id){\n\t\t\t\tif(!verticesHash[id]){\n\t\t\t\t\tverticesHash[id] = {id: id, onStack:false, index: undefined, lowLink: undefined, edge: undefined};\n\t\t\t\t}\n\n\t\t\t\treturn verticesHash[id];\n\t\t\t}\n\t\t},\n\n\t\tfindLoops: function(relations){\n\t\t\tvar cycles = [];\n\n\t\t\thelpers.forEach(relations, function(rel){\n\t\t\t\tif(rel.target == rel.source)\n\t\t\t\t\tcycles.push([rel.target, rel.source]);\n\t\t\t});\n\n\t\t\tvar vertices = this.getVertices(relations);\n\n\t\t\tvar connectedComponents = this.tarjanStronglyConnectedComponents(vertices, relations);\n\t\t\thelpers.forEach(connectedComponents, function(component){\n\t\t\t\tif(component.tasks.length > 1){\n\t\t\t\t\tcycles.push(component);//{ tasks: [task ids], links: [links ids]}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn cycles;\n\t\t\t//{task:id, link:link.type, lag: link.lag || 0, source: link.source}\n\t\t}\n\t};\n};","module.exports = function (gantt) {\n\t// helpers for building chain of dependencies, used for critical path calculation and for auto scheduling\n\n\tgantt._get_linked_task = function (link, getTarget) {\n\t\tvar task = null;\n\t\tvar taskId = getTarget ? link.target : link.source;\n\n\t\tif (gantt.isTaskExists(taskId)) {\n\t\t\ttask = gantt.getTask(taskId);\n\t\t}\n\n\t\treturn task;\n\t};\n\tgantt._get_link_target = function (link) {\n\t\treturn gantt._get_linked_task(link, true);\n\t};\n\n\tgantt._get_link_source = function (link) {\n\t\treturn gantt._get_linked_task(link, false);\n\t};\n\n\tvar caching = false;\n\tvar formattedLinksStash = {};\n\tvar inheritedSuccessorsStash = {};\n\tvar inheritedPredecessorsStash = {};\n\tvar getPredecessorsCache = {};\n\n\n\tgantt._isLinksCacheEnabled = function () {\n\t\treturn caching;\n\t};\n\tgantt._startLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = true;\n\t};\n\tgantt._endLinksCache = function () {\n\t\tformattedLinksStash = {};\n\t\tinheritedSuccessorsStash = {};\n\t\tinheritedPredecessorsStash = {};\n\t\tgetPredecessorsCache = {};\n\t\tcaching = false;\n\t};\n\n\tgantt._formatLink = function (link) {\n\n\n\t\tif (caching && formattedLinksStash[link.id]) {\n\t\t\treturn formattedLinksStash[link.id];\n\t\t}\n\n\t\tvar relations = [];\n\t\tvar target = this._get_link_target(link);\n\t\tvar source = this._get_link_source(link);\n\n\t\tif (!(source && target)) {\n\t\t\treturn relations;\n\t\t}\n\n\t\tif ((gantt.isSummaryTask(target) && gantt.isChildOf(source.id, target.id)) || (gantt.isSummaryTask(source) && gantt.isChildOf(target.id, source.id))) {\n\t\t\treturn relations;\n\t\t}\n\n\n\t\t// there are three kinds of connections at this point\n\t\t// task -> task - regular link\n\t\t// task -> project - transform it into set of regular links (task -> [each subtask]), use offset beetween subtask and project dates as lag, in order not to change mutual positions of subtasks inside a project\n\t\t// project -> task - transform it into ([each subtask] -> task) links\n\t\t// project -> project - transform it into ([each subtask of p1] -> [each subtask of p2]) links\n\n\t\tvar from = this._getImplicitLinks(link, source, function (c) {\n\t\t\treturn 0;\n\t\t}, true);\n\n\t\tvar respectTargetOffset = gantt.config.auto_scheduling_move_projects;\n\t\tvar targetDates = this.isSummaryTask(target) ? this.getSubtaskDates(target.id) : {\n\t\t\tstart_date: target.start_date,\n\t\t\tend_date: target.end_date\n\t\t};\n\t\tvar to = this._getImplicitLinks(link, target, function (c) {\n\t\t\tif (!respectTargetOffset) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\n\t\t\t\tif (!c.$target.length && !(gantt.getState().drag_id == c.id)) {// drag_id - virtual lag shouldn't restrict task that is being moved inside project\n\t\t\t\t\treturn gantt.calculateDuration({\n\t\t\t\t\t\tstart_date: targetDates.start_date,\n\t\t\t\t\t\tend_date: c.start_date,\n\t\t\t\t\t\ttask: source\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (var i = 0, fromLength = from.length; i < fromLength; i++) {\n\t\t\tvar fromTask = from[i];\n\t\t\tfor (var j = 0, toLength = to.length; j < toLength; j++) {\n\t\t\t\tvar toTask = to[j];\n\n\t\t\t\tvar lag = fromTask.lag * 1 + toTask.lag * 1;\n\n\t\t\t\tvar subtaskLink = {\n\t\t\t\t\tid: link.id,\n\t\t\t\t\ttype: link.type,\n\t\t\t\t\tsource: fromTask.task,\n\t\t\t\t\ttarget: toTask.task,\n\t\t\t\t\tlag: (link.lag * 1 || 0) + lag\n\t\t\t\t};\n\n\t\t\t\trelations.push(gantt._convertToFinishToStartLink(toTask.task, subtaskLink, source, target, fromTask.taskParent, toTask.taskParent));\n\t\t\t}\n\t\t}\n\n\t\tif (caching)\n\t\t\tformattedLinksStash[link.id] = relations;\n\n\t\treturn relations;\n\t};\n\n\tgantt._isAutoSchedulable = function (task) {\n\t\treturn task.auto_scheduling !== false;\n\t};\n\n\tgantt._getImplicitLinks = function (link, parent, selectOffset, selectSourceLinks) {\n\t\tvar relations = [];\n\n\t\tif (this.isSummaryTask(parent)) {\n\n\t\t\t// if the summary task contains multiple chains of linked tasks - no need to consider every task of the chain,\n\t\t\t// it will be enough to check the first/last tasks of the chain\n\t\t\t// special conditions if there are unscheduled tasks in the chain, or negative lag values that put the end date of the successor task prior to its predecessors' date\n\t\t\tvar children = {};\n\t\t\tthis.eachTask(function (c) {\n\t\t\t\tif (!this.isSummaryTask(c)) {\n\t\t\t\t\tchildren[c.id] = c;\n\t\t\t\t}\n\t\t\t}, parent.id);\n\n\t\t\tvar skipChild;\n\n\t\t\tfor (var c in children) {\n\t\t\t\tvar task = children[c];\n\t\t\t\tvar linksCollection = selectSourceLinks ? task.$source : task.$target;\n\n\t\t\t\tskipChild = false;\n\n\t\t\t\tfor (var l = 0; l < linksCollection.length; l++) {\n\t\t\t\t\tvar siblingLink = gantt.getLink(linksCollection[l]);\n\t\t\t\t\tvar siblingId = selectSourceLinks ? siblingLink.target : siblingLink.source;\n\t\t\t\t\tvar siblingTask = children[siblingId];\n\t\t\t\t\tif (siblingTask && task.auto_scheduling !== false && siblingTask.auto_scheduling !== false) {\n\t\t\t\t\t\tif ((siblingLink.target == siblingTask.id && Math.abs(siblingLink.lag) <= siblingTask.duration) ||\n\t\t\t\t\t\t\t(siblingLink.target == task.id && Math.abs(siblingLink.lag) <= task.duration)) {\n\t\t\t\t\t\t\tskipChild = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!skipChild) {\n\t\t\t\t\trelations.push({ task: task.id, taskParent: task.parent, lag: selectOffset(task) });\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\trelations.push({ task: parent.id, taskParent: parent.parent, lag: 0 });\n\t\t}\n\n\t\treturn relations;\n\t};\n\n\tgantt._getDirectDependencies = function (task, selectSuccessors) {\n\n\t\tvar links = [],\n\t\t\tsuccessors = [];\n\n\t\tvar linksIds = selectSuccessors ? task.$source : task.$target;\n\n\t\tfor (var i = 0; i < linksIds.length; i++) {\n\t\t\tvar link = this.getLink(linksIds[i]);\n\t\t\tif (this.isTaskExists(link.source) && this.isTaskExists(link.target)) {\n\t\t\t\tvar target = this.getTask(link.target);\n\t\t\t\tif (this._isAutoSchedulable(target)) {\n\t\t\t\t\tlinks.push(this.getLink(linksIds[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < links.length; i++) {\n\t\t\tsuccessors = successors.concat(this._formatLink(links[i]));\n\t\t}\n\n\t\treturn successors;\n\t};\n\n\tgantt._getInheritedDependencies = function (task, selectSuccessors) {\n\n\t\t//var successors = [];\n\t\tvar stop = false;\n\t\tvar inheritedRelations = [];\n\t\tvar cacheCollection;\n\t\tif (this.isTaskExists(task.id)) {\n\t\t\tthis.eachParent(function (parent) {\n\t\t\t\tif (stop)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (caching) {\n\t\t\t\t\tcacheCollection = selectSuccessors ? inheritedSuccessorsStash : inheritedPredecessorsStash;\n\t\t\t\t\tif (cacheCollection[parent.id]) {\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(cacheCollection[parent.id]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar parentDependencies;\n\t\t\t\tif (this.isSummaryTask(parent)) {\n\t\t\t\t\tif (!this._isAutoSchedulable(parent)) {\n\t\t\t\t\t\tstop = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparentDependencies = this._getDirectDependencies(parent, selectSuccessors);\n\t\t\t\t\t\tif (caching) {\n\t\t\t\t\t\t\tcacheCollection[parent.id] = parentDependencies;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tinheritedRelations = inheritedRelations.concat(parentDependencies);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}, task.id, this);\n\t\t}\n\n\t\treturn inheritedRelations;\n\t};\n\n\n\tgantt._getDirectSuccessors = function (task) {\n\t\treturn this._getDirectDependencies(task, true);\n\t};\n\n\tgantt._getInheritedSuccessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, true);\n\t};\n\n\tgantt._getDirectPredecessors = function (task) {\n\t\treturn this._getDirectDependencies(task, false);\n\t};\n\n\tgantt._getInheritedPredecessors = function (task) {\n\t\treturn this._getInheritedDependencies(task, false);\n\t};\n\n\tgantt._getSuccessors = function (task, skipInherited) {\n\t\tvar successors = this._getDirectSuccessors(task);\n\t\tif (skipInherited) {\n\t\t\treturn successors;\n\t\t} else {\n\t\t\treturn successors.concat(this._getInheritedSuccessors(task));\n\t\t}\n\t};\n\n\tgantt._getPredecessors = function (task, skipInherited) {\n\t\tvar key = String(task.id) + \"-\" + String(skipInherited);\n\t\tvar result;\n\n\t\tif (caching && getPredecessorsCache[key]) {\n\t\t\treturn getPredecessorsCache[key];\n\t\t}\n\n\t\tvar predecessors = this._getDirectPredecessors(task);\n\t\tif (skipInherited) {\n\t\t\tresult = predecessors;\n\t\t} else {\n\t\t\tresult = predecessors.concat(this._getInheritedPredecessors(task));\n\t\t}\n\t\tif (caching) {\n\t\t\tgetPredecessorsCache[key] = result;\n\t\t}\n\t\treturn result;\n\t};\n\n\n\tgantt._convertToFinishToStartLink = function (id, link, sourceTask, targetTask, sourceParent, targetParent) {\n\t\t// convert finish-to-finish, start-to-finish and start-to-start to finish-to-start link and provide some additional properties\n\t\tvar res = {\n\t\t\ttarget: id,\n\t\t\tlink: gantt.config.links.finish_to_start,\n\t\t\tid: link.id,\n\t\t\tlag: link.lag || 0,\n\t\t\tsource: link.source,\n\t\t\tpreferredStart: null,\n\t\t\tsourceParent: sourceParent,\n\t\t\ttargetParent: targetParent,\n\t\t\thashSum: null\n\t\t};\n\n\t\tvar additionalLag = 0;\n\t\tswitch (link.type) {\n\t\t\tcase gantt.config.links.start_to_start:\n\t\t\t\tadditionalLag = -sourceTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.finish_to_finish:\n\t\t\t\tadditionalLag = -targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tcase gantt.config.links.start_to_finish:\n\t\t\t\tadditionalLag = -sourceTask.duration - targetTask.duration;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tadditionalLag = 0;\n\t\t}\n\n\t\tres.lag += additionalLag;\n\t\tres.hashSum = res.lag + \"_\" + res.link + \"_\" + res.source + \"_\" + res.target;\n\t\treturn res;\n\t};\n};","import { ConnectedGroupsHelper } from \"./connected_groups\";\n\nexport function attachUIHandlers(\n\tgantt: any,\n\tlinksBuilder: any,\n\tloopsFinder: any,\n\tconnectedGroupsHelper: ConnectedGroupsHelper\n) {\n\tlet _attachAutoSchedulingHandlers = function() {\n\t\tlet _scheduleAfterBatchUpdate = false;\n\t\tgantt.attachEvent(\"onAfterBatchUpdate\", function(){\n\n\t\t\tif(_scheduleAfterBatchUpdate){\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t\t_scheduleAfterBatchUpdate = false;\n\t\t});\n\n\t\tfunction _autoScheduleAfterLinkChange(id: LinkID, link: ILink) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif(gantt.getState().batch_update){\n\t\t\t\t\t_scheduleAfterBatchUpdate = true;\n\t\t\t\t}else{\n\t\t\t\t\tgantt.autoSchedule(link.source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgantt.attachEvent(\"onAfterLinkUpdate\", _autoScheduleAfterLinkChange);\n\t\tgantt.attachEvent(\"onAfterLinkAdd\", _autoScheduleAfterLinkChange);\n\n\t\tgantt.attachEvent(\"onAfterLinkDelete\", function(id: LinkID, link: ILink) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\t!gantt._autoscheduling_in_progress &&\n\t\t\t\tgantt.isTaskExists(link.target)\n\t\t\t) {\n\t\t\t\t// after link deleted - auto schedule target for other relations that may be left\n\t\t\t\tconst target = gantt.getTask(link.target);\n\t\t\t\tconst predecessors = gantt._getPredecessors(target);\n\t\t\t\tif (predecessors.length) {\n\t\t\t\t\tif(gantt.getState().batch_update){\n\t\t\t\t\t\t_scheduleAfterBatchUpdate = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tgantt.autoSchedule(predecessors[0].source, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tgantt.attachEvent(\"onParse\", function() {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_initial\n\t\t\t) {\n\t\t\t\tgantt.autoSchedule();\n\t\t\t}\n\t\t});\n\n\t\tfunction _preventCircularLink(id: LinkID, link: ILink): boolean {\n\t\t\tif (gantt.isCircularLink(link)) {\n\t\t\t\tgantt.callEvent(\"onCircularLinkError\", [\n\t\t\t\t\tlink,\n\t\t\t\t\tloopsFinder.getLoopContainingLink(link)\n\t\t\t\t]);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction _preventDescendantLink(id: LinkID, link: ILink): boolean {\n\t\t\tconst source = gantt.getTask(link.source);\n\t\t\tconst target = gantt.getTask(link.target);\n\n\t\t\tif (!gantt.config.auto_scheduling_descendant_links) {\n\t\t\t\tif (\n\t\t\t\t\t(gantt.isChildOf(source.id, target.id) &&\n\t\t\t\t\t\tgantt.isSummaryTask(target)) ||\n\t\t\t\t\t(gantt.isChildOf(target.id, source.id) && gantt.isSummaryTask(source))\n\t\t\t\t) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkAdd\", _preventDescendantLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventCircularLink);\n\t\tgantt.attachEvent(\"onBeforeLinkUpdate\", _preventDescendantLink);\n\n\t\tfunction _datesNotEqual(\n\t\t\tdateA: Date,\n\t\t\tdateB: Date,\n\t\t\ttaskA: ITask,\n\t\t\ttaskB: ITask\n\t\t): boolean {\n\t\t\tif (!!dateA !== !!dateB) {\n\t\t\t\t// if one of dates is empty or null and the other is not\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!dateA && !dateB) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (dateA.valueOf() > dateB.valueOf()) {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateB,\n\t\t\t\t\tend_date: dateA,\n\t\t\t\t\ttask: taskB\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn gantt._hasDuration({\n\t\t\t\t\tstart_date: dateA,\n\t\t\t\t\tend_date: dateB,\n\t\t\t\t\ttask: taskA\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfunction _notEqualTaskDates(task1: ITask, task2: ITask): boolean {\n\t\t\tif (_datesNotEqual(task1.start_date, task2.start_date, task1, task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (gantt.getConstraintType(task1) !== gantt.getConstraintType(task2)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(\n\t\t\t\t\ttask1.constraint_date,\n\t\t\t\t\ttask2.constraint_date,\n\t\t\t\t\ttask1,\n\t\t\t\t\ttask2\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\t_datesNotEqual(task1.start_date, task2.start_date, task1, task2) ||\n\t\t\t\t((_datesNotEqual(task1.end_date, task2.end_date, task1, task2) ||\n\t\t\t\t\ttask1.duration !== task2.duration) &&\n\t\t\t\t\ttask1.type !== gantt.config.types.milestone)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tfunction getRelations(id: TaskID) {\n\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility) {\n\t\t\t\t// collect only downstream dependencies since there is no backward or ALAP scheduling in pre 6.1 auto scheduling\n\t\t\t\treturn linksBuilder.getLinkedTasks(id, true);\n\t\t\t} else {\n\t\t\t\t// get all connected group (both upstream and downstream dependencies)\n\t\t\t\treturn connectedGroupsHelper.getConnectedGroupRelations(id);\n\t\t\t}\n\t\t}\n\n\t\tlet relations;\n\t\tlet movedTask;\n\t\tgantt.attachEvent(\"onBeforeTaskDrag\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\tif (\n\t\t\t\tgantt.config.auto_scheduling &&\n\t\t\t\tgantt.config.auto_scheduling_move_projects\n\t\t\t) {\n\t\t\t\t// collect relations before drag and drop  in order to have original positions of subtasks within project since they are used as lag when moving dependent project\n\t\t\t\trelations = getRelations(id);\n\n\t\t\t\tmovedTask = id;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\tfunction resetToStartLinksLags(taskId, relationsArray) {\n\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish_to_start links\n\t\t\t// recalculate these links if task duration has changed\n\n\t\t\tlet skipped = false;\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst originalLink = gantt.getLink(relationsArray[i].id);\n\t\t\t\tif (\n\t\t\t\t\toriginalLink &&\n\t\t\t\t\t(originalLink.type === gantt.config.links.start_to_start ||\n\t\t\t\t\t\toriginalLink.type === gantt.config.links.start_to_finish)\n\t\t\t\t) {\n\t\t\t\t\trelationsArray.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\tskipped = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (skipped) {\n\t\t\t\tconst presentLinks = {};\n\t\t\t\tfor (let i = 0; i < relationsArray.length; i++) {\n\t\t\t\t\tpresentLinks[relationsArray[i].id] = true;\n\t\t\t\t}\n\n\t\t\t\tconst updatedLinks = getRelations(taskId);\n\n\t\t\t\tfor (let i = 0; i < updatedLinks.length; i++) {\n\t\t\t\t\tif (!presentLinks[updatedLinks[i].id]) {\n\t\t\t\t\t\trelationsArray.push(updatedLinks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction updateTaskConstraints(task){\n\t\t\tif (gantt.config.schedule_from_end) {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.FNLT;\n\t\t\t\ttask.constraint_date = new Date(task.end_date);\n\t\t\t} else {\n\t\t\t\ttask.constraint_type = gantt.config.constraint_types.SNET;\n\t\t\t\ttask.constraint_date = new Date(task.start_date);\n\t\t\t}\n\t\t}\n\n\t\tfunction finalizeTaskConstraints(task){\n\t\t\t// TODO: remove in 7.0\n\t\t\tif (gantt.config.auto_scheduling_compatibility && gantt.config.auto_scheduling_strict) {\n\t\t\t\tif (task.constraint_type === gantt.config.constraint_types.SNET ||\n\t\t\t\t\ttask.constraint_type === gantt.config.constraint_types.FNLT) {\n\t\t\t\t\t\ttask.constraint_type = null;\n\t\t\t\t\t\ttask.constraint_date = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst _autoScheduleAfterDND = function(taskId, task) {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tconst newTask = gantt.getTask(taskId);\n\n\t\t\t\tif (_notEqualTaskDates(task, newTask)) {\n\t\t\t\t\tupdateTaskConstraints(newTask);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tgantt.config.auto_scheduling_move_projects &&\n\t\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\t\tmovedTask == taskId\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tgantt.calculateDuration(task) !== gantt.calculateDuration(newTask)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// task duration is used as lag when converting start_to_start and start_to_finish into finish to start links\n\t\t\t\t\t\t\t// recalculate these links if task duration has changed\n\t\t\t\t\t\t\tresetToStartLinksLags(taskId, relations);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgantt._autoSchedule(taskId, relations);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgantt.autoSchedule(newTask.id);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinalizeTaskConstraints(newTask);\n\t\t\t\t}\n\t\t\t}\n\t\t\trelations = null;\n\t\t\tmovedTask = null;\n\t\t\treturn true;\n\t\t};\n\n\n\n\n\t\tlet modifiedTaskId = null;\n\t\tif (gantt.ext && gantt.ext.inlineEditors) {\n\t\t\tconst inlineEditors = gantt.ext.inlineEditors;\n\t\t\tconst autoscheduleColumns = {\n\t\t\t\tstart_date: true,\n\t\t\t\tend_date: true,\n\t\t\t\tduration: true,\n\t\t\t\tconstraint_type: true,\n\t\t\t\tconstraint_date: true\n\t\t\t};\n\n\t\t\tinlineEditors.attachEvent(\"onBeforeSave\", function(state) {\n\t\t\t\tif (autoscheduleColumns[state.columnName]) {\n\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tlet changedConstraint;\n\t\tfunction onBeforeLigthboxSaveHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tchangedConstraint = false;\n\t\t\t\tconst oldTask = gantt.getTask(taskId);\n\t\t\t\tif (_notEqualTaskDates(task, oldTask)) {\n\t\t\t\t\tmodifiedTaskId = taskId;\n\t\t\t\t\tif(gantt.getConstraintType(task) !== gantt.getConstraintType(oldTask) ||\n\t\t\t\t\t\t+task.constraint_date !== +oldTask.constraint_date\n\t\t\t\t\t){\n\t\t\t\t\t\tchangedConstraint = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction onAfterTaskUpdateHandler(taskId: TaskID, task: ITask): boolean {\n\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\tif (\n\t\t\t\t\tmodifiedTaskId &&\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t\tmodifiedTaskId == taskId\n\t\t\t\t) {\n\t\t\t\t\tmodifiedTaskId = null;\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tupdateTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t\tgantt.autoSchedule(task.id);\n\n\t\t\t\t\tif(!changedConstraint){\n\t\t\t\t\t\tfinalizeTaskConstraints(task);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tgantt.attachEvent(\"onBeforeTaskChanged\", function(\n\t\t\tid: TaskID,\n\t\t\tmode: string,\n\t\t\ttask: ITask\n\t\t) {\n\t\t\treturn _autoScheduleAfterDND(id, task);\n\t\t});\n\n\t\tif(gantt.ext.inlineEditors){\n\t\t\tgantt.ext.inlineEditors.attachEvent(\"onBeforeSave\", function(state){\n\t\t\t\tif (gantt.config.auto_scheduling && !gantt._autoscheduling_in_progress) {\n\t\t\t\t\tconst api = gantt.ext.inlineEditors;\n\t\t\t\t\tconst editorConfig = api.getEditorConfig(state.columnName);\n\t\t\t\t\tif(editorConfig.map_to === \"start_date\" || editorConfig.map_to === \"end_date\" || editorConfig.map_to === \"duration\"){\n\t\t\t\t\t\tmodifiedTaskId = state.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t});\n\t\t}\n\n\t\tgantt.attachEvent(\"onLightboxSave\", onBeforeLigthboxSaveHandler);\n\t\tgantt.attachEvent(\"onAfterTaskUpdate\", onAfterTaskUpdateHandler);\n\t};\n\n\tgantt.attachEvent(\"onGanttReady\", function() {\n\t\t_attachAutoSchedulingHandlers();\n\t\t// attach handlers only when initialized for the first time\n\t\t_attachAutoSchedulingHandlers = function() { };\n\t});\n}\n","export class LoopsFinder {\n\tprivate _linksBuilder: any;\n\tprivate _graphHelper: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, graphHelper: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._gantt = gantt;\n\t}\n\tisCircularLink = (link: ILink): boolean => {\n\t\treturn !!this.getLoopContainingLink(link);\n\t}\n\n\tgetLoopContainingLink = (link: ILink): any => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\t\tconst gantt = this._gantt;\n\n\t\tlet allRelations = linksBuilder.getLinkedTasks();\n\t\tif (!gantt.isLinkExists(link.id)) {\n\t\t\tallRelations = allRelations.concat(gantt._formatLink(link));\n\t\t}\n\n\t\tconst cycles = graphHelper.findLoops(allRelations);\n\n\t\tconst found = false;\n\t\tfor (let i = 0; i < cycles.length && !found; i++) {\n\t\t\tconst links = cycles[i].links;\n\t\t\tfor (let j = 0; j < links.length; j++) {\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif (links[j] == link.id) {\n\t\t\t\t\treturn cycles[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tfindCycles = () => {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst linksBuilder = this._linksBuilder;\n\n\t\tconst allRelations = linksBuilder.getLinkedTasks();\n\t\treturn graphHelper.findLoops(allRelations);\n\t}\n}\n","interface IFlagHash {\n\t[id: string]: boolean;\n}\n\nfunction findGroups(links: IInternalLink[]): IConnectedGroup[] {\n\tconst visited: IFlagHash = {};\n\tconst groups = [];\n\tlet source: TaskID;\n\tlet target: TaskID;\n\tlet root: TaskID;\n\t// main loop - find any unvisited vertex from the input array and\n\t// treat it as the source, then perform a breadth first search from\n\t// it. All vertices visited from this search belong to the same group\n\tfor (let i = 0; i < links.length; i++) {\n\t\tsource = links[i].source;\n\t\ttarget = links[i].target;\n\t\troot = null;\n\t\tif (!visited[source]) {\n\t\t\troot = source;\n\t\t} else if (!visited[target]) {\n\t\t\troot = target;\n\t\t}\n\t\tif (root) {\n\t\t\t// there is an unvisited vertex in this pair.\n\t\t\t// perform a breadth first search, and push the resulting\n\t\t\t// group onto the list of all groups\n\t\t\tconst length = links.length;\n\t\t\tgroups.push(breadthFirstSearch(root, links, visited));\n\t\t\tif (length !== links.length) {\n\t\t\t\ti = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn groups;\n}\n\n// Breadth First Search function\n// v is the source vertex\n// links is the input array, which contains all gantt relations\n// visited is a dictionary for keeping track of whether a node is visited\nfunction breadthFirstSearch(\n\tv: TaskID,\n\tlinks: IInternalLink[],\n\tvisited: IFlagHash\n): IConnectedGroupsDetailed {\n\tconst queue: TaskID[] = [v];\n\tconst groupTasks: TaskID[] = [];\n\tconst groupLinksInternal: { [hashSum: string]: IInternalLink } = {};\n\tconst groupLinksPublic: { [id: string]: boolean } = {};\n\n\tlet currentVertex: TaskID;\n\twhile (queue.length > 0) {\n\t\tcurrentVertex = queue.shift();\n\t\tif (!visited[currentVertex]) {\n\t\t\tvisited[currentVertex] = true;\n\t\t\tgroupTasks.push(currentVertex);\n\t\t\t// go through the input array to find vertices that are\n\t\t\t// directly adjacent to the current vertex, and put them\n\t\t\t// onto the queue\n\t\t\tfor (let i = 0; i < links.length; i++) {\n\t\t\t\tconst link = links[i];\n\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\tif ((link.source == currentVertex || link.sourceParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.target]) {\n\t\t\t\t\t\tqueue.push(link.target);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\n\t\t\t\t\t// tslint:disable-next-line triple-equals\n\t\t\t\t} else if ((link.target == currentVertex || link.targetParent == currentVertex)) {\n\t\t\t\t\tif (!visited[link.source]) {\n\t\t\t\t\t\tqueue.push(link.source);\n\t\t\t\t\t\tgroupLinksPublic[link.id] = true;\n\t\t\t\t\t\tlinks.splice(i, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tgroupLinksInternal[link.hashSum] = link;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tconst linksArray: LinkID[] = [];\n\tconst linksObjects: IInternalLink[] = [];\n\tfor (const i in groupLinksPublic) {\n\t\tlinksArray.push(i);\n\t}\n\tfor (const i in groupLinksInternal) {\n\t\tlinksObjects.push(groupLinksInternal[i]);\n\t}\n\t// return everything in the current \"group\"\n\treturn { tasks: groupTasks, links: linksArray, processedLinks: linksObjects };\n}\n\nexport class ConnectedGroupsHelper {\n\tprivate _linksBuilder: any;\n\tprivate _gantt: any;\n\tconstructor(gantt: any, linksBuilder: any) {\n\t\tthis._linksBuilder = linksBuilder;\n\t\tthis._gantt = gantt;\n\t}\n\n\tgetConnectedGroupRelations = (id: TaskID): IInternalLink[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tconst group = breadthFirstSearch(id, links, {});\n\t\treturn group.processedLinks;\n\t}\n\n\tgetConnectedGroup = (id: TaskID): IConnectedGroup | IConnectedGroup[] => {\n\t\tconst links = this._linksBuilder.getLinkedTasks();\n\t\tif (id !== undefined) {\n\t\t\tif (this._gantt.getTask(id).type === this._gantt.config.types.project) {\n\t\t\t\treturn { tasks: [], links: [] };\n\t\t\t}\n\n\t\t\tconst group = breadthFirstSearch(id, links, {});\n\t\t\treturn {\n\t\t\t\ttasks: group.tasks,\n\t\t\t\tlinks: group.links\n\t\t\t};\n\t\t} else {\n\t\t\treturn findGroups(links).map(group => ({ tasks: group.tasks, links: group.links }));\n\t\t}\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AsapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AsapStrategy {\n\t\tconst instance = new AsapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\tresolveRelationDate(\n\t\ttaskId: TaskID,\n\t\tadjacentLinks: ITaskRelations,\n\t\tplansHash: IPlansHash\n\t): TaskPlan {\n\t\tlet minStart = null;\n\t\tlet linkId = null;\n\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.predecessors;\n\n\t\tlet minRelationDate = null;\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\n\t\t\tconst constraintDate = this.getEarliestStartDate(\n\t\t\t\trelation,\n\t\t\t\tplansHash,\n\t\t\t\ttask\n\t\t\t);\n\n\t\t\tif (this.isSmallerOrDefault(minRelationDate, constraintDate, task)) {\n\t\t\t\tminRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (\n\t\t\t\tthis.isSmallerOrDefault(defaultStart, constraintDate, task) &&\n\t\t\t\tthis.isSmallerOrDefault(minStart, constraintDate, task)\n\t\t\t) {\n\t\t\t\tminStart = constraintDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_start) {\n\t\t\tif (this.isSmallerOrDefault(task.start_date, this._gantt.config.project_start, task)) {\n\t\t\t\tminStart = this._gantt.config.project_start;\n\t\t\t}\n\t\t}\n\n\t\tlet maxEnd = null;\n\t\tif (minStart) {\n\t\t\tminStart = this._gantt.getClosestWorkTime({\n\t\t\t\tdate: minStart,\n\t\t\t\tdir: \"future\",\n\t\t\t\ttask\n\t\t\t});\n\t\t\tmaxEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minStart,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\tconst masterPlan = plansHash[taskId];\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.start_date = minStart;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.kind = \"asap\";\n\n\t\tif (minRelationDate) {\n\t\t\tcurrentPlan.earliestSchedulingStart = minRelationDate;\n\t\t\tcurrentPlan.earliestSchedulingEnd = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: minRelationDate,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn currentPlan;\n\t}\n\n\tprotected isEqual(dateA: Date, dateB: Date, task: ITask): boolean {\n\t\treturn !this._gantt._hasDuration(dateA, dateB, task);\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && !this.isEqual(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isSmallerOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(smallDate, bigDate, task));\n\t}\n\n\tprotected getPredecessorEndDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.end_date;\n\t\t} else if (plan.end_date) {\n\t\t\tres = plan.end_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: plan.start_date,\n\t\t\t\tduration: task.duration,\n\t\t\t\ttask\n\t\t\t});\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getEarliestStartDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask): Date {\n\t\tconst predecessorEnd = this.getPredecessorEndDate(\n\t\t\trelation.source,\n\t\t\tplansHash\n\t\t);\n\t\tconst successor = task;\n\n\t\tlet successorStart = this._gantt.getClosestWorkTime({\n\t\t\tdate: predecessorEnd,\n\t\t\tdir: \"future\",\n\t\t\ttask: successor\n\t\t});\n\n\t\tif (\n\t\t\tpredecessorEnd &&\n\t\t\trelation.lag &&\n\t\t\trelation.lag * 1 === relation.lag * 1\n\t\t) {\n\t\t\tsuccessorStart = this._gantt.calculateEndDate({\n\t\t\t\tstart_date: predecessorEnd,\n\t\t\t\tduration: relation.lag * 1,\n\t\t\t\ttask: successor\n\t\t\t});\n\t\t}\n\n\t\treturn successorStart;\n\t}\n}\n","import { TaskPlan } from \"./task_plan\";\n\nexport class AlapStrategy implements ISchedulingStrategy {\n\tstatic Create(gantt: any): AlapStrategy {\n\t\tconst instance = new AlapStrategy();\n\t\tinstance._gantt = gantt;\n\t\treturn instance;\n\t}\n\n\tprotected _gantt: any;\n\n\n\tresolveRelationDate(taskId: TaskID, adjacentLinks: ITaskRelations, plansHash: IPlansHash): TaskPlan {\n\t\tlet maxEnd = null;\n\t\tlet linkId = null;\n\t\tlet maxStart = null;\n\t\tlet defaultStart = null;\n\t\tconst task = this._gantt.getTask(taskId);\n\t\tconst relations = adjacentLinks.successors;\n\t\tlet maxRelationDate = null;\n\t\tconst masterPlan = plansHash[taskId];\n\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\tconst relation = relations[i];\n\n\t\t\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t\t\t// will be removed in future versions\n\t\t\t// TODO: remove .preferredStart in v7.0\n\t\t\tdefaultStart = relation.preferredStart;\n\t\t\tconst constraintDate = this.getLatestEndDate(relation, plansHash, task);\n\t\t\tconst constraintStartDate = this._gantt.calculateEndDate({ start_date: constraintDate, duration: - task.duration, task });\n\n\t\t\tif (this.isGreaterOrDefault(maxRelationDate, constraintDate, task)) {\n\t\t\t\tmaxRelationDate = constraintDate;\n\t\t\t}\n\t\t\tif (this.isGreaterOrDefault(defaultStart, constraintStartDate, task) && this.isGreaterOrDefault(maxEnd, constraintDate, task)) {\n\t\t\t\tmaxEnd = constraintDate;\n\t\t\t\tmaxStart = constraintStartDate;\n\t\t\t\tlinkId = relation.id;\n\t\t\t}\n\t\t}\n\n\t\tif (!relations.length && this._gantt.config.project_end) {\n\t\t\tif (this.isGreaterOrDefault(this._gantt.config.project_end, task.end_date, task)) {\n\t\t\t\tmaxEnd = this._gantt.config.project_end;\n\t\t\t}\n\t\t}\n\n\t\tif (maxEnd) {\n\n\t\t\tmaxEnd = this._gantt.getClosestWorkTime({ date: maxEnd, dir: \"future\", task });\n\t\t\tmaxStart = this._gantt.calculateEndDate({ start_date: maxEnd, duration: - task.duration, task });\n\t\t}\n\n\t\tconst currentPlan = TaskPlan.Create(masterPlan);\n\n\t\tcurrentPlan.link = linkId;\n\t\tcurrentPlan.task = taskId;\n\t\tcurrentPlan.end_date = maxEnd;\n\t\tcurrentPlan.start_date = maxStart;\n\t\tcurrentPlan.kind = \"alap\";\n\n\t\tif (maxRelationDate) {\n\t\t\tcurrentPlan.latestSchedulingStart = this._gantt.calculateEndDate({ start_date: maxRelationDate, duration: - task.duration, task });\n\t\t\tcurrentPlan.latestSchedulingEnd = maxRelationDate;\n\t\t}\n\n\t\treturn currentPlan;\n\n\t}\n\n\tprotected isFirstSmaller(small: Date, big: Date, task: ITask): boolean {\n\t\tif (small.valueOf() < big.valueOf() && this._gantt._hasDuration(small, big, task)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprotected isGreaterOrDefault(smallDate: Date, bigDate: Date, task: ITask): boolean {\n\t\treturn !!(!smallDate || this.isFirstSmaller(bigDate, smallDate, task));\n\t}\n\n\tprotected getSuccessorStartDate(id: TaskID, plansHash: IPlansHash): Date {\n\t\tconst plan = plansHash[id];\n\t\tconst task = this._gantt.getTask(id);\n\t\tlet res;\n\n\t\tif (!(plan && (plan.start_date || plan.end_date))) {\n\t\t\tres = task.start_date;\n\t\t} else if (plan.start_date) {\n\t\t\tres = plan.start_date;\n\t\t} else {\n\t\t\tres = this._gantt.calculateEndDate({ start_date: plan.end_date, duration: - task.duration, task });\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprotected getLatestEndDate(relation: IInternalLink, plansHash: IPlansHash, task: ITask) {\n\t\tconst successorStart = this.getSuccessorStartDate(relation.target, plansHash);\n\t\tconst predecessor = task;\n\n\t\tlet predecessorEnd = this._gantt.getClosestWorkTime({ date: successorStart, dir: \"past\", task: predecessor });\n\n\t\tif (predecessorEnd && relation.lag && relation.lag * 1 === relation.lag * 1) {\n\t\t\tpredecessorEnd = this._gantt.calculateEndDate({ start_date: predecessorEnd, duration: -relation.lag * 1, task: predecessor });\n\t\t}\n\n\t\treturn predecessorEnd;\n\t}\n}","import { AlapStrategy } from \"./alap_strategy\";\nimport { AsapStrategy } from \"./asap_strategy\";\nimport { ConstraintTypes } from \"./constraint_types\";\nimport { ConstraintsHelper } from \"./constraints\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class AutoSchedulingPlanner {\n\tprivate _gantt: any;\n\tprivate _constraintsHelper: ConstraintsHelper;\n\tprivate _graphHelper: any;\n\tprivate _asapStrategy: AsapStrategy;\n\tprivate _alapStrategy: AlapStrategy;\n\n\tconstructor(\n\t\tgantt: any,\n\t\tgraphHelper: any,\n\t\tconstraintsHelper: ConstraintsHelper\n\t) {\n\t\tthis._gantt = gantt;\n\t\tthis._constraintsHelper = constraintsHelper;\n\t\tthis._graphHelper = graphHelper;\n\t\tthis._asapStrategy = AsapStrategy.Create(gantt);\n\t\tthis._alapStrategy = AlapStrategy.Create(gantt);\n\t}\n\n\tgeneratePlan(relations: IInternalLink[], constraints: ITask[]): TaskPlan[] {\n\t\tconst graphHelper = this._graphHelper;\n\t\tconst gantt = this._gantt;\n\t\tconst constraintsHelper = this._constraintsHelper;\n\t\tconst alapStrategy = this._alapStrategy;\n\t\tconst asapStrategy = this._asapStrategy;\n\n\t\tconst {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash } = this.buildWorkCollections(relations, constraints, graphHelper);\n\n\t\tlet result: TaskPlan[];\n\n\t\tthis.processConstraints(orderedIds, plansHash, gantt, constraintsHelper);\n\n\t\tif (gantt.config.schedule_from_end) {\n\t\t\t// when scheduling from end - iterate tasks from end and schedule them as late as possible\n\t\t\t// after that - iterate tasks from start and schedule asap tasks\n\t\t\tresult = this.iterateTasks(reversedIds, orderedIds, constraintsHelper.isAlapTask, alapStrategy, asapStrategy, relationsMap, plansHash);\n\t\t} else {\n\t\t\t// when scheduling from end - iterate tasks from start and schedule them as soon as possible\n\t\t\t// after that - iterate tasks from end and schedule asap alap\n\t\t\tresult = this.iterateTasks(orderedIds, reversedIds, constraintsHelper.isAsapTask, asapStrategy, alapStrategy, relationsMap, plansHash);\n\t\t}\n\t\treturn result;\n\t}\n\n\tapplyProjectPlan(projectPlan: TaskPlan[]): ITask[] {\n\t\tconst gantt = this._gantt;\n\n\t\tlet plan: TaskPlan;\n\t\tlet task: ITask;\n\t\tlet link: ILink;\n\t\tlet reason: ITask;\n\n\t\tconst updateTasks = [];\n\t\tfor (let i = 0; i < projectPlan.length; i++) {\n\t\t\tlink = null;\n\t\t\treason = null;\n\t\t\tplan = projectPlan[i];\n\n\t\t\tif (!plan.task) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask = gantt.getTask(plan.task);\n\t\t\tif (plan.link) {\n\t\t\t\tlink = gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet newDate = null;\n\t\t\tif (\n\t\t\t\tplan.start_date &&\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf()\n\t\t\t) {\n\t\t\t\tnewDate = plan.start_date;\n\t\t\t}\n\n\t\t\tif (!newDate) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttask.start_date = newDate;\n\t\t\ttask.end_date = gantt.calculateEndDate(task);\n\n\t\t\tupdateTasks.push(task.id);\n\t\t\tgantt.callEvent(\"onAfterTaskAutoSchedule\", [\n\t\t\t\ttask,\n\t\t\t\tnewDate,\n\t\t\t\tlink,\n\t\t\t\treason\n\t\t\t]);\n\t\t}\n\t\treturn updateTasks;\n\t}\n\n\tprotected iterateTasks(\n\t\tmainSequence: TaskID[],\n\t\tsecondarySequence: TaskID[],\n\t\tisMainSequence: (task: ITask) => boolean,\n\t\tmainSequenceStrategy: ISchedulingStrategy,\n\t\tsecondarySequenceStrategy: ISchedulingStrategy,\n\t\trelationsMap: ITaskLinksMap,\n\t\tplansHash: IPlansHash\n\n\t): TaskPlan[] {\n\t\tconst gantt = this._gantt;\n\t\tconst result: TaskPlan[] = [];\n\n\t\tfor (let i = 0; i < mainSequence.length; i++) {\n\t\t\tconst currentId = mainSequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\t\t\tconst plan = mainSequenceStrategy.resolveRelationDate(\n\t\t\t\tcurrentId,\n\t\t\t\trelationsMap[currentId],\n\t\t\t\tplansHash\n\t\t\t);\n\t\t\tthis.limitPlanDates(task, plan);\n\t\t\tif (isMainSequence(task)) {\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t} else {\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < secondarySequence.length; i++) {\n\t\t\tconst currentId = secondarySequence[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tif (!isMainSequence(task)) {\n\t\t\t\tconst plan = secondarySequenceStrategy.resolveRelationDate(\n\t\t\t\t\tcurrentId,\n\t\t\t\t\trelationsMap[currentId],\n\t\t\t\t\tplansHash\n\t\t\t\t);\n\t\t\t\tthis.limitPlanDates(task, plan);\n\t\t\t\tthis.processResolvedDate(task, plan, result, plansHash);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected processResolvedDate(\n\t\ttask: ITask,\n\t\tplan: TaskPlan,\n\t\tresult: TaskPlan[],\n\t\tplansHash: any\n\t): void {\n\t\tif (plan.start_date && this._gantt.isLinkExists(plan.link)) {\n\t\t\tlet link = null;\n\t\t\tlet reason = null;\n\t\t\tif (plan.link) {\n\t\t\t\tlink = this._gantt.getLink(plan.link);\n\t\t\t\tif (plan.kind === \"asap\") {\n\t\t\t\t\treason = this._gantt.getTask(link.source);\n\t\t\t\t} else {\n\t\t\t\t\t// alap tasks are scheduled by their successors\n\t\t\t\t\treason = this._gantt.getTask(link.target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\ttask.start_date.valueOf() !== plan.start_date.valueOf() &&\n\t\t\t\tthis._gantt.callEvent(\"onBeforeTaskAutoSchedule\", [\n\t\t\t\t\ttask,\n\t\t\t\t\tplan.start_date,\n\t\t\t\t\tlink,\n\t\t\t\t\treason\n\t\t\t\t]) === false\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tplansHash[task.id] = plan;\n\t\tif (plan.start_date) {\n\t\t\tresult.push(plan);\n\t\t}\n\t}\n\n\tprotected limitPlanDates(task: ITask, plan: TaskPlan): TaskPlan {\n\t\tconst effectiveStart = plan.start_date || task.start_date;\n\n\t\tif (plan.earliestStart) {\n\t\t\tif (effectiveStart < plan.earliestStart) {\n\t\t\t\tplan.start_date = plan.earliestStart;\n\t\t\t\tplan.end_date = plan.earliestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestStart) {\n\t\t\tif (effectiveStart > plan.latestStart) {\n\t\t\t\tplan.start_date = plan.latestStart;\n\t\t\t\tplan.end_date = plan.latestEnd;\n\t\t\t}\n\t\t}\n\n\t\tif (plan.latestSchedulingStart && effectiveStart > plan.latestSchedulingStart) {\n\t\t\tplan.start_date = plan.latestSchedulingStart;\n\t\t\tplan.end_date = plan.latestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.earliestSchedulingStart && effectiveStart < plan.earliestSchedulingStart) {\n\t\t\tplan.start_date = plan.earliestSchedulingStart;\n\t\t\tplan.end_date = plan.earliestSchedulingEnd;\n\t\t}\n\n\t\tif (plan.start_date) { // start/end dates are either both defined or both not\n\t\t\tif (plan.start_date > plan.latestSchedulingStart ||\n\t\t\t\tplan.start_date < plan.earliestSchedulingStart ||\n\t\t\t\tplan.start_date > plan.latestStart ||\n\t\t\t\tplan.start_date < plan.earliestStart ||\n\t\t\t\tplan.end_date > plan.latestSchedulingEnd ||\n\t\t\t\tplan.end_date < plan.earliestSchedulingEnd ||\n\t\t\t\tplan.end_date > plan.latestEnd ||\n\t\t\t\tplan.end_date < plan.earliestEnd) {\n\n\t\t\t\tplan.conflict = true;\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tprotected buildWorkCollections(relations: IInternalLink[], constraints: ITask[], graphHelper: any) {\n\t\tconst gantt = this._gantt;\n\t\tconst orderedIds: TaskID[] = graphHelper.topologicalSort(relations);\n\t\tconst reversedIds: TaskID[] = orderedIds.slice().reverse();\n\t\tconst plansHash: IPlansHash = {};\n\n\t\tconst relationsMap: ITaskLinksMap = {};\n\t\tfor (let i = 0, len = orderedIds.length; i < len; i++) {\n\t\t\tconst id = orderedIds[i];\n\t\t\tconst task = gantt.getTask(id);\n\t\t\tif (task.auto_scheduling === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trelationsMap[id] = {\n\t\t\t\tsuccessors: [],\n\t\t\t\tpredecessors: []\n\t\t\t};\n\n\t\t\tplansHash[id] = null;\n\t\t}\n\n\t\tfor (let i = 0, len = constraints.length; i < len; i++) {\n\t\t\tconst task = constraints[i];\n\n\t\t\tif (plansHash[task.id] === undefined) {\n\t\t\t\treversedIds.unshift(task.id);\n\t\t\t\torderedIds.unshift(task.id);\n\t\t\t\tplansHash[task.id] = null;\n\t\t\t\trelationsMap[task.id] = {\n\t\t\t\t\tsuccessors: [],\n\t\t\t\t\tpredecessors: []\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, len = relations.length; i < len; i++) {\n\t\t\tconst rel = relations[i];\n\t\t\tif (relationsMap[rel.source]) {\n\t\t\t\trelationsMap[rel.source].successors.push(rel);\n\t\t\t}\n\n\t\t\tif (relationsMap[rel.target]) {\n\t\t\t\trelationsMap[rel.target].predecessors.push(rel);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\torderedIds,\n\t\t\treversedIds,\n\t\t\trelationsMap,\n\t\t\tplansHash\n\t\t};\n\t}\n\n\tprotected processConstraints(orderedIds: TaskID[], plansHash: IPlansHash, gantt: any, constraintsHelper: ConstraintsHelper) {\n\t\tfor (let i = 0; i < orderedIds.length; i++) {\n\t\t\tconst currentId = orderedIds[i];\n\t\t\tconst task = gantt.getTask(currentId);\n\n\t\t\tconst constraintType = constraintsHelper.getConstraintType(task);\n\t\t\tif (\n\t\t\t\tconstraintType &&\n\t\t\t\tconstraintType !== ConstraintTypes.ASAP &&\n\t\t\t\tconstraintType !== ConstraintTypes.ALAP\n\t\t\t) {\n\t\t\t\tconst plan = constraintsHelper.processConstraint(\n\t\t\t\t\ttask,\n\t\t\t\t\tTaskPlan.Create()\n\t\t\t\t);\n\t\t\t\tplansHash[task.id] = plan;\n\t\t\t}\n\t\t}\n\t}\n}\n","import * as helpers from \"../../utils/helpers\";\nimport { ConstraintTypes } from \"./constraint_types\";\nimport { TaskPlan } from \"./task_plan\";\n\nexport class ConstraintsHelper {\n\tstatic Create(gantt: any): ConstraintsHelper {\n\t\treturn new ConstraintsHelper(gantt);\n\t}\n\n\tprivate _gantt: any;\n\tprivate constructor(gantt: any) {\n\t\tthis._gantt = gantt;\n\t}\n\n\tisAsapTask = (task: ITask): boolean => {\n\t\tconst constraintType = this.getConstraintType(task);\n\t\tif (this._gantt.config.schedule_from_end) {\n\t\t\tif (constraintType === ConstraintTypes.ASAP) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (constraintType === ConstraintTypes.ALAP) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tisAlapTask = (task: ITask): boolean => {\n\t\treturn !this.isAsapTask(task);\n\t}\n\n\tgetConstraintType = (task: ITask): ConstraintTypes => {\n\t\t// in case of backward scheduling, tasks without explicit constraints are considered ALAP tasks\n\t\tif (task.constraint_type) {\n\t\t\treturn task.constraint_type;\n\t\t} else if (this._gantt.config.schedule_from_end) {\n\t\t\treturn ConstraintTypes.ALAP;\n\t\t} else {\n\t\t\treturn ConstraintTypes.ASAP;\n\t\t}\n\t}\n\n\thasConstraint = (task: ITask): boolean => {\n\t\treturn !!this.getConstraintType(task);\n\t}\n\n\tprocessConstraint = (task: ITask, plan: TaskPlan): TaskPlan => {\n\t\tif (this.hasConstraint(task)) {\n\t\t\tif (\n\t\t\t\ttask.constraint_type === ConstraintTypes.ALAP ||\n\t\t\t\ttask.constraint_type === ConstraintTypes.ASAP\n\t\t\t) {\n\t\t\t\t// this kind of constraint is calculated after main scheduling\n\t\t\t} else if(helpers.isValidDate(task.constraint_date)) {\n\t\t\t\tconst constraintDate = task.constraint_date;\n\n\t\t\t\tconst newPlan = TaskPlan.Create(plan);\n\t\t\t\tnewPlan.task = task.id;\n\n\t\t\t\tswitch (task.constraint_type) {\n\t\t\t\t\tcase ConstraintTypes.SNET:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.SNLT:\n\t\t\t\t\t\tnewPlan.latestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.latestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.latestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNET:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.FNLT:\n\t\t\t\t\t\tnewPlan.latestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestEnd = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MSO:\n\t\t\t\t\t\tnewPlan.earliestStart = new Date(constraintDate);\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ConstraintTypes.MFO:\n\t\t\t\t\t\tnewPlan.earliestStart = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: constraintDate,\n\t\t\t\t\t\t\tduration: -task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.earliestEnd = this._gantt.calculateEndDate({\n\t\t\t\t\t\t\tstart_date: newPlan.earliestStart,\n\t\t\t\t\t\t\tduration: task.duration,\n\t\t\t\t\t\t\ttask\n\t\t\t\t\t\t});\n\t\t\t\t\t\tnewPlan.latestStart = newPlan.earliestStart;\n\t\t\t\t\t\tnewPlan.latestEnd = newPlan.earliestEnd;\n\t\t\t\t\t\tnewPlan.link = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\treturn newPlan;\n\t\t\t}\n\t\t}\n\n\t\treturn plan;\n\t}\n\n\tgetConstraints = (id: TaskID, relations: IInternalLink[]): ITask[] => {\n\t\tconst result = [];\n\t\tconst tasks = {};\n\n\t\tconst store = (task: any) => {\n\t\t\tif (tasks[task.id]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (this.hasConstraint(task) && !this._gantt.isSummaryTask(task)) {\n\t\t\t\ttasks[task.id] = task;\n\t\t\t}\n\t\t};\n\n\t\tif (this._gantt.isTaskExists(id)) {\n\t\t\tconst task = this._gantt.getTask(id);\n\t\t\tstore(task);\n\t\t}\n\n\t\tthis._gantt.eachTask(task => store(task), id);\n\n\t\tlet current;\n\t\tif (relations) {\n\t\t\tfor (let i = 0; i < relations.length; i++) {\n\t\t\t\tconst rel = relations[i];\n\t\t\t\tif (!tasks[rel.target]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.target);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t\tif (!tasks[rel.source]) {\n\t\t\t\t\tcurrent = this._gantt.getTask(rel.source);\n\t\t\t\t\tstore(current);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const taskId in tasks) {\n\t\t\tresult.push(tasks[taskId]);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","require(\"../core/relations/links_common\")(gantt);\n\nvar linksBuilder = require(\"../core/relations/links_builder\")(gantt);\nvar graphHelper = require(\"../core/relations/graph_helper\")(gantt);\nvar ConstraintTypes = require(\"./auto_scheduling/constraint_types\").ConstraintTypes;\n\nvar constraintsHelper = require(\"./auto_scheduling/constraints\").ConstraintsHelper.Create(\n\tgantt\n);\nvar AutoSchedulingPlanner = require(\"./auto_scheduling/planner\")\n\t.AutoSchedulingPlanner;\n\nvar planner = new AutoSchedulingPlanner(gantt, graphHelper, constraintsHelper);\n\nvar ConnectedGroupsHelper = require(\"./auto_scheduling/connected_groups\")\n\t.ConnectedGroupsHelper;\nvar connectedGroups = new ConnectedGroupsHelper(gantt, linksBuilder);\n\nvar LoopsFinder = require(\"./auto_scheduling/loops_finder\").LoopsFinder;\n\nvar loopsFinder = new LoopsFinder(\n\tgantt,\n\tgraphHelper,\n\tlinksBuilder\n);\n\ngantt.getConnectedGroup = connectedGroups.getConnectedGroup;\ngantt.getConstraintType = constraintsHelper.getConstraintType;\ngantt.getConstraintLimitations = function (task) {\n\tvar plan = constraintsHelper.processConstraint(task, null);\n\treturn {\n\t\tearliestStart: plan.earliestStart || null,\n\t\tearliestEnd: plan.earliestEnd || null,\n\t\tlatestStart: plan.latestStart || null,\n\t\tlatestEnd: plan.latestEnd || null\n\t};\n};\n\ngantt.isCircularLink = loopsFinder.isCircularLink;\ngantt.findCycles = loopsFinder.findCycles;\n\ngantt.config.constraint_types = ConstraintTypes;\ngantt.config.auto_scheduling = false;\ngantt.config.auto_scheduling_descendant_links = false;\ngantt.config.auto_scheduling_initial = true;\ngantt.config.auto_scheduling_strict = false;\ngantt.config.auto_scheduling_move_projects = true;\ngantt.config.project_start = null;\ngantt.config.project_end = null;\ngantt.config.schedule_from_end = false;\n\nfunction preferInitialTaskDates(startTask, relations) {\n\t// TODO: remove in 7.0\n\tif (!gantt.config.auto_scheduling_compatibility) {\n\t\treturn;\n\t}\n\n\t// .preferredStart still exists only to emulate pre 6.1 auto scheduling behavior\n\t// will be removed in future versions\n\tfor (var i = 0; i < relations.length; i++) {\n\t\tvar rel = relations[i];\n\t\tvar task = gantt.getTask(rel.target);\n\n\t\tif (!gantt.config.auto_scheduling_strict || rel.target == startTask) {\n\t\t\trel.preferredStart = new Date(task.start_date);\n\t\t}\n\t}\n}\n\nfunction updateParentsAndCallEvents(updatedTasks) {\n\tfunction resetTime(task) {\n\t\tif (batchUpdate)\n\t\t\treturn;\n\n\t\tvar start = task.start_date.valueOf(),\n\t\t\tend = task.end_date.valueOf();\n\n\t\tgantt.resetProjectDates(task);\n\t\tif (task.start_date.valueOf() != start || task.end_date.valueOf() != end) {\n\t\t\tbatchUpdate = true;\n\t\t\treturn;\n\t\t}\n\t\tvar children = gantt.getChildren(task.id);\n\t\tfor (var i = 0; !batchUpdate && i < children.length; i++) {\n\t\t\tresetTime(gantt.getTask(children[i]));\n\t\t}\n\t}\n\n\tvar batchUpdate = false;\n\t// call batchUpdate (full repaint) only if we update multiple tasks,\n\tif (updatedTasks.length == 1) {\n\t\tgantt.eachParent(resetTime, updatedTasks[0]);\n\t} else if (updatedTasks.length) {\n\t\tbatchUpdate = true;\n\t}\n\n\tfunction payload() {\n\t\tfor (var i = 0; i < updatedTasks.length; i++) {\n\t\t\tgantt.updateTask(updatedTasks[i]);\n\t\t}\n\t}\n\tif (batchUpdate) {\n\t\tgantt.batchUpdate(payload);\n\t} else {\n\t\tpayload();\n\t}\n}\n\ngantt._autoSchedule = function (id, relations) {\n\tif (gantt.callEvent(\"onBeforeAutoSchedule\", [id]) === false) {\n\t\treturn;\n\t}\n\tgantt._autoscheduling_in_progress = true;\n\n\tvar constraints = constraintsHelper.getConstraints(\n\t\tid,\n\t\tgantt.isTaskExists(id) ? relations : null\n\t);\n\n\tvar updatedTasks = [];\n\n\tvar cycles = graphHelper.findLoops(relations);\n\tif (cycles.length) {\n\t\tgantt.callEvent(\"onAutoScheduleCircularLink\", [cycles]);\n\t} else {\n\t\tpreferInitialTaskDates(id, relations);\n\n\t\tvar plan = planner.generatePlan(relations, constraints);\n\t\tupdatedTasks = planner.applyProjectPlan(plan);\n\n\t\tupdateParentsAndCallEvents(updatedTasks);\n\t}\n\n\tgantt._autoscheduling_in_progress = false;\n\tgantt.callEvent(\"onAfterAutoSchedule\", [id, updatedTasks]);\n};\n\ngantt.autoSchedule = function (id, inclusive) {\n\tif (inclusive === undefined) {\n\t\tinclusive = true;\n\t} else {\n\t\tinclusive = !!inclusive;\n\t}\n\n\tvar relations;\n\tif (id !== undefined) {\n\t\tif (gantt.config.auto_scheduling_compatible) {\n\t\t\tlinksBuilder.getLinkedTasks(id, inclusive);\n\t\t} else {\n\t\t\trelations = connectedGroups.getConnectedGroupRelations(id);\n\t\t}\n\t} else {\n\t\trelations = linksBuilder.getLinkedTasks();\n\t}\n\n\tgantt._autoSchedule(id, relations);\n};\n\ngantt.attachEvent(\"onTaskLoading\", function (task) {\n\tif (task.constraint_date && typeof task.constraint_date === \"string\") {\n\t\ttask.constraint_date = gantt.date.parseDate(task.constraint_date, \"parse_date\");\n\t}\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\ngantt.attachEvent(\"onTaskCreated\", function (task) {\n\ttask.constraint_type = gantt.getConstraintType(task);\n\treturn true;\n});\n\nvar attachUIHandlers = require(\"./auto_scheduling/ui_handlers\").attachUIHandlers;\nattachUIHandlers(gantt, linksBuilder, loopsFinder, connectedGroups);\n","export class TaskPlan implements ITaskPlan {\n\tstatic Create(parent?: TaskPlan): TaskPlan {\n\t\tconst plan = new TaskPlan();\n\t\tif (parent) {\n\t\t\tfor (const i in plan) {\n\t\t\t\tif (parent[i] !== undefined) {\n\t\t\t\t\tplan[i] = parent[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn plan;\n\t}\n\n\tpublic link: string | number;\n\tpublic task: string | number;\n\t// tslint:disable-next-line variable-name\n\tpublic start_date: Date | null;\n\t// tslint:disable-next-line variable-name\n\tpublic end_date: Date | null;\n\n\tpublic latestStart: Date;\n\tpublic earliestStart: Date;\n\tpublic earliestEnd: Date;\n\tpublic latestEnd: Date;\n\n\tpublic latestSchedulingStart: Date;\n\tpublic earliestSchedulingStart: Date;\n\tpublic latestSchedulingEnd: Date;\n\tpublic earliestSchedulingEnd: Date;\n\n\tpublic kind: string;\n\tpublic conflict: boolean;\n\n\tconstructor() {\n\t\tthis.link = null;\n\t\tthis.task = null;\n\t\tthis.start_date = null;\n\t\tthis.end_date = null;\n\t\tthis.latestStart = null;\n\t\tthis.earliestStart = null;\n\t\tthis.earliestEnd = null;\n\t\tthis.latestEnd = null;\n\t\tthis.latestSchedulingStart = null;\n\t\tthis.earliestSchedulingStart = null;\n\t\tthis.latestSchedulingEnd = null;\n\t\tthis.earliestSchedulingEnd = null;\n\t\tthis.kind = \"asap\";\n\t\tthis.conflict = false;\n\t}\n}"],"sourceRoot":""}